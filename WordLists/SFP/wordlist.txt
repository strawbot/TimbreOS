Word list for firmware  generated by parsewords.py  Feb 05, 2015  10:30:12

 [v] for variable
 [i] for compile words
 ( a - b ) stack before operation 'a' and after operation 'b'; right is top

!   ( n a - ) store next into memory using top as address (processor sized)
"  [i]  ( - s ) enclose text up to next " in a count prefixed string
#   ( n - n' ) convert a digit from n
#>   ( n - a c ) finish number sequence and return address and count
#s   ( n - 0 ) convert all digits in n
'  [i]  ( - a ) get execution address of following word
(  [i]  start of comment till end of line or )
*   ( n m - p ) multiply next data stack item by top and leave on top
+   ( n m - p ) add top two data stack items and leave on top
+b   ( b a - ) turn on b bits at address a: 0b10001 em +b
,   ( n - ) allocate 1 cell and put n into it
-   ( n m - p ) subtract top data stack item from next item and leave on top
-b   ( b a - ) turn off b bits at address a: 0b10001 em -b
.   ( n - ) print n in current number base
."  [i]  print text up until next "
.b   ( n - ) print n in binary
.d   ( n - ) print n in decimal
.h   ( n - ) print n in hex
.r   ( m n - ) print m in right field of n digits
.s   print number of items on data stack
/   ( n m - q ) divide next data stack item by top and leave on top
/mod   ( n m - q r ) return divide and modulus from top item into next item
0stats   reset machine stats
:   start a macro definition
;  [i]  end a macro
<   ( n m - f ) leave a boolean on stack indicating if next is less than top
<#   inititiate a number sequence
=   ( n m - f ) leave a boolean on stack after equating top two data stack items
>   ( n m - f ) leave a boolean on stack indicating if next is greater than top
>b   ( a - ) put machine into execution queue
>r   ( n - ) (R - n ) push the top item of the data stack onto the return stack
?dup   ( n - n n | - 0 ) duplicate top data stack item if not 0
@   ( a - n ) return contents of memory using top stack item as the address (processor sized)
[  [i]  exit macro mode
]   enter macro mode
abs   ( n - n|-n) top data stack item is made positive
again  [i]  end of a continuous loop construct
allot   ( n - ) reserve n bytes after end of dictionary
and   ( n m - p ) bitwise AND top two data stack items and leave on top
base   ( - a ) return address of number radix
begin  [i]  start of a loop construct
c!   ( c a - ) store next into memory using top as address (8 bit)
c,   ( c - ) allocate and 1 byte and put value in it
c@   ( a - c ) return contents of memory using top stack item as the address (8 bit)
cmove   ( s d n - ) move n bytes from s to d
constant   ( n - ) give n a name
count   ( a - a' c ) leave first character and incremented address on stack
cr   send end of line to output device
cs   set link statistics to zero
dbg  [v]  set debug level 0 - quiet, 1 state changes, 2 traffic: 2 dbg c!
decimal   interpret all subsequent numbers as decimal
df   dump link frame buffers
dl   display link state
drop   ( n - ) throw away the top data stack item
dump   ( a n - ) dump n 16-byte rows of memory starting at address a
dup   ( n - n n ) make a copy of the top data stack item
else  [i]  otherwise part of an if statement
emit   ( c - ) send c to output device
end   end and report interval length
endif  [i]  end of else or if statement
erase   ( s n - ) erase n bytes from s
execute   ( a - ) use the top data stack item as a function call
exit  [i]  exit macro
fill   ( s n x - )fill n bytes from s with x
for  [i]  ( n - ) start of a loop which runs n times
here   ( - a ) return address of end of dictionary
hex   interpret all following numbers as hex
hold   ( c - ) hold a character in number sequence
if  [i]  ( n - ) execute following code if top of stack is non-zero
koff   turn off automatic key echo
kon   turn on automatic key echo
l!   (n a - )store next into memory using top as address (processor sized)
l@   ( a - n )return contents of memory using top stack item as the address (32 bit)
literal  [i]  ( n - ) enter a literal value into a macro
lm   list machines
load   ( link n - ) load the sfp link with n frames
ls   display link statistics
max   ( n m - n|m) leave maximum of top two stack items
min    ( n m - n|m) leave minimum of top two stack items
mod   ( n m - r ) modulus next data stack item by top and leave on top
negate   ( n - -n ) two's complement of top data stack item
next  [i]  end of a for loop
not   ( n - n' ) invert all bits on the top data stack item
or    ( n m - p ) bitwise OR top two data stack items and leave on top
over   ( n m - n m n ) copy 2nd data stack item to top of data stack
ping   ( i n - ) get response time to n pings to link i
r   ( - n ) (R n - n ) copy the top item of the return stack onto the data stack
r>    ( - n ) (R n - ) move top item on return stack to data stack
repeat  [i]  go back to the begin part
reveal  [i]  allow macro to call itself
s!   ( h a - ) store next into memory using top as address (16 bit)
s@   ( a - h ) return contents of memory using top stack item as the address (16 bit)
shift   ( n m - p ) shift n by m bit left for minus and right for positive
sign   ( n - ) prepend sign to number sequence if n is negative
sp!   ( ... - ) empty the data stack
start   note start of an interval
stats   show time statistics on machine loop
swap   ( n m - m n ) swap top two items on the data stack
time   display timestamp
type   ( a n - ) output n characters starting at a
u<   ( u v - f ) leave a boolean on stack indicating if unsigned next is less than top
u>   ( u b - f ) leave a boolean on stack indicating if unsigned next is greater than top
until  [i]  ( n - ) go back to the begin statement if stack is zero
variable   ( n - ) give n a place to be stored at a name
while  [i]  ( n - ) conditional choice in a loop construct
word   ( c - ) parse characters up to c from input to here
words   list all words in dictionary
xor   ( n m - p ) bitwise XOR top two data stack items and leave on top
