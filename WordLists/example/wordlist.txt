Word list for firmware  generated by parsewords.py  Mar 03, 2017  10:09:14

 [v] for variable
 [i] for compile words
 ( a - b ) stack before operation 'a' and after operation 'b'; right is top

!   ( n a - ) store next into memory using top as address (processor sized)
#   ( n - n' ) convert a digit from n
#>   ( n - a c ) finish number sequence and return address and count
#s   ( n - 0 ) convert all digits in n
(  [i]  start of comment till end of line or )
*   ( n m - p ) multiply next data stack item by top and leave on top
+   ( n m - p ) add top two data stack items and leave on top
+b   ( b a - ) turn on b bits at address a: 0b10001 em +b
,   ( n -s ) allocate 1 cell and put n into it
-   ( n m - p ) subtract top data stack item from next item and leave on top
-b   ( b a - ) turn off b bits at address a: 0b10001 em -b
.   ( n - ) print n in current number base
.b   ( n - ) print number in binary
.d   ( n - ) print number in decimal
.h   ( n - ) print number in hex
.r   ( m n - ) print m in right field of n digits
.s   print number of items on data stack and items
/   ( n m - q ) divide next data stack item by top and leave on top
/mod   ( n m - q r ) return divide and modulus from top item into next item
:   start a macro definition
;  [i]  end a macro
<   ( n m - f ) leave a boolean on stack indicating if next is less than top
<#   inititiate a number sequence
=   ( n m - f ) leave a boolean on stack after equating top two data stack items
>   ( n m - f ) leave a boolean on stack indicating if next is greater than top
>r   ( n - ) (R - n ) push the top item of the data stack onto the return stack
?dup   ( n - n n | - 0 ) duplicate top data stack item if not 0
@   ( a - n ) return contents of memory using top stack item as the address (processor sized)
[  [i]  exit macro mode
]   enter macro mode
abs   ( n - |n|) top data stack item is made positive
again  [i]  end of a continuous loop construct
allot   ( n - ) reserve n bytes after end of dictionary
and   ( n m - p ) bitwise AND top two data stack items and leave on top
begin  [i]  start of a loop construct
bin   switch to binary numbers
c!   ( c a - ) store next into memory using top as address (8 bit)
c,   ( c - ) allocate and 1 byte and put value in it
c@   ( a - c ) return contents of memory using top stack item as the address (8 bit)
cmove   ( s d n - ) move n bytes from s to d
constant   ( n - ) give n a name
count   ( a - a' c ) leave first character and incremented address on stack
cr   send end of line to output device
decimal   interpret all subsequent numbers as decimal
drop   ( n - ) throw away the top data stack item
dump   ( a n - ) dump n 16-byte rows of memory starting at address a
dup   ( n - n n ) make a copy of the top data stack item
else  [i]  otherwise part of an if statement
emit   ( c - ) send c to output device
endif  [i]  end of else or if statement
erase   ( s n - ) erase n bytes from s
execute   ( a - ) use the top data stack item as a function call
exit  [i]  exit macro
fill   ( s n x - )fill n bytes from s with x
for  [i]  ( n - ) start of a loop which runs n times
help   print words with one line help; allow wild card filtering
here   ( - a ) return address of end of dictionary
hex   interpret all following numbers as hex
hold   ( c - ) hold a character in number sequence
if  [i]  ( n - ) execute following code if top of stack is non-zero
l!   (n a - )store next into memory using top as address (processor sized)
l@   ( a - n )return contents of memory using top stack item as the address (32 bit)
max   ( n m - n|m) leave maximum of top two stack items
min    ( n m - n|m) leave minimum of top two stack items
mod   ( n m - r ) modulus next data stack item by top and leave on top
negate   ( n - -n ) two's complement of top data stack item
next  [i]  end of a for loop
not   ( n - n' ) invert all bits on the top data stack item
oct   switch to octal numbers
or    ( n m - p ) bitwise OR top two data stack items and leave on top
over   ( n m - n m n ) copy 2nd data stack item to top of data stack
r   ( - n ) (R n - n ) copy the top item of the return stack onto the data stack
r>    ( - n ) (R n - ) move top item on return stack to data stack
repeat  [i]  go back to the begin part
reset   reset everything including removing all definitions
s!   ( h a - ) store next into memory using top as address (16 bit)
s@   ( a - h ) return contents of memory using top stack item as the address (16 bit)
shift   ( n m - p ) shift n by m bit left for minus and right for positive
sign   ( n - ) prepend sign to number sequence if n is negative
sp!   ( ... - ) empty the data stack
swap   ( n m - m n ) swap top two items on the data stack
type   ( a n - ) output n characters starting at a
until  [i]  ( n - ) go back to the begin statement if stack is zero
variable   ( n - ) give n a place to be stored at a name
while  [i]  ( n - ) conditional choice in a loop construct
words   list all words in dictionary
words   list all words in dictionary
xor   ( n m - p ) bitwise XOR top two data stack items and leave on top
